/**
 * Remotion Plugin - Timeline Schema
 *
 * Zod schemas for the timeline.json format that drives dynamic video compositions.
 * These schemas validate timeline data loaded from JSON files.
 *
 * The timeline.json is typically generated by:
 * 1. Writing a script for each scene
 * 2. Running generate_voice.py for each scene
 * 3. Running concat_audio.py to merge audio and produce timestamps
 * 4. Building the timeline.json with scene content + audio timestamps
 */

import { z } from "zod";

// ─── Audio Element ─────────────────────────────────────────────────────────
// Represents the continuous narration audio track
export const AudioElementSchema = z.object({
  /** Path to the audio file relative to public/ */
  audioUrl: z.string(),
  /** Start time in milliseconds */
  startMs: z.number().min(0),
  /** End time in milliseconds */
  endMs: z.number().min(0),
});

// ─── Text Element ──────────────────────────────────────────────────────────
// Subtitle/caption text synchronized with audio
export const TextElementSchema = z.object({
  /** Display text */
  text: z.string(),
  /** Start time in milliseconds */
  startMs: z.number().min(0),
  /** End time in milliseconds */
  endMs: z.number().min(0),
  /** Text style */
  style: z.enum(["subtitle", "title", "heading", "caption"]).default("subtitle"),
  /** Text position */
  position: z.enum(["top", "center", "bottom"]).default("bottom"),
});

// ─── Background Element ────────────────────────────────────────────────────
// Visual background for each scene
export const BackgroundElementSchema = z.object({
  /** Background type */
  type: z.enum(["color", "image", "gradient"]).default("color"),
  /** Color value (for type: color) */
  color: z.string().optional(),
  /** Image path relative to public/ (for type: image) */
  imageUrl: z.string().optional(),
  /** Gradient CSS value (for type: gradient) */
  gradient: z.string().optional(),
  /** Start time in milliseconds */
  startMs: z.number().min(0),
  /** End time in milliseconds */
  endMs: z.number().min(0),
  /** Enter transition effect */
  enterTransition: z.enum(["fade", "blur", "slide", "none"]).default("fade"),
  /** Exit transition effect */
  exitTransition: z.enum(["fade", "blur", "slide", "none"]).default("fade"),
  /** Animation during display */
  animation: z.enum(["zoomIn", "zoomOut", "panLeft", "panRight", "none"]).default("none"),
});

// ─── Scene Definition ──────────────────────────────────────────────────────
// A complete scene with visual and content configuration
export const SceneSchema = z.object({
  /** Unique scene identifier */
  id: z.string(),
  /** Scene title */
  title: z.string(),
  /** Scene description or narration text */
  text: z.string().optional(),
  /** Bullet points for content scenes */
  points: z.array(z.string()).optional(),
  /** Background color */
  background: z.string().optional(),
  /** Background image path relative to public/ */
  backgroundImage: z.string().optional(),
  /** Start time in milliseconds */
  startMs: z.number().min(0),
  /** End time in milliseconds */
  endMs: z.number().min(0),
  /** Scene visual style */
  style: z.enum(["title", "content", "image", "split", "outro"]).default("content"),
});

// ─── Complete Timeline ─────────────────────────────────────────────────────
// The full timeline that drives a video composition
export const TimelineSchema = z.object({
  /** Video title */
  title: z.string(),
  /** Short title for intros */
  shortTitle: z.string().optional(),
  /** Path to continuous narration MP3 relative to public/ */
  narrationFile: z.string(),
  /** Total duration in milliseconds */
  totalDurationMs: z.number().min(0),
  /** FPS (default 30) */
  fps: z.number().default(30),
  /** Video width */
  width: z.number().default(1920),
  /** Video height */
  height: z.number().default(1080),
  /** Scene definitions */
  scenes: z.array(SceneSchema),
  /** Background elements (optional, for image-based videos) */
  elements: z.array(BackgroundElementSchema).optional(),
  /** Text/subtitle elements (optional, for subtitle overlay) */
  text: z.array(TextElementSchema).optional(),
  /** Audio segments (optional, if using segmented audio) */
  audio: z.array(AudioElementSchema).optional(),
});

// ─── Type Exports ──────────────────────────────────────────────────────────

export type AudioElement = z.infer<typeof AudioElementSchema>;
export type TextElement = z.infer<typeof TextElementSchema>;
export type BackgroundElement = z.infer<typeof BackgroundElementSchema>;
export type Scene = z.infer<typeof SceneSchema>;
export type Timeline = z.infer<typeof TimelineSchema>;

// ─── Utility Functions ─────────────────────────────────────────────────────

/**
 * Calculate frame timing from millisecond timestamps.
 * ALWAYS uses Math.ceil to prevent audio cutting.
 */
export const calculateFrameTiming = (
  startMs: number,
  endMs: number,
  fps: number = 30,
  offsetFrames: number = 0
) => {
  const startFrame = Math.ceil((startMs * fps) / 1000) + offsetFrames;
  const durationFrames = Math.ceil(((endMs - startMs) * fps) / 1000);

  return { startFrame, durationFrames };
};

/**
 * Calculate total composition duration from timeline.
 * Adds 1 second padding to prevent audio cutoff at the end.
 */
export const calculateTotalDuration = (
  timeline: Timeline,
  paddingSeconds: number = 1.0
): number => {
  const fps = timeline.fps || 30;
  const totalMs = timeline.totalDurationMs;
  const totalFrames = Math.ceil((totalMs / 1000) * fps);
  const paddingFrames = Math.ceil(paddingSeconds * fps);

  return totalFrames + paddingFrames;
};
